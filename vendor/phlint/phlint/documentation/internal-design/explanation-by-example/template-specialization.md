
Home: [Documentation](/documentation/index.md)

Parent: [Internal Design: Explanation by Example](/documentation/internal-design/explanation-by-example/index.md)

Explanation by Example: Template Specialization
===============================================

Example
-------

    <?php

    function sum ($a, $b) {
      return $a + $b;
    }

    $x = sum(5, 6);

Explanation
-----------

For languages that compile into machine native code, like for example C, each variable has to have a type, and
each type must be known at compile type. Why? Because depending on a type a certain instruction is used for a certain
operation. A `+` operation on two `int` variables might be reduced to a single instruction that does only that.

In PHP however, the expression `"2" + 2` yields `4` - which is great, obvious and easy to write. In PHP each variable
consists of type and value pair and they are carried around as one. Why? Because both are needed for PHP to evaluate
such expression, do the necessary type conversion, and yield the result.

In fairness we could make C do the same thing, after all PHP is written in C, but we would need to use a library
that would do all type comparisons and conversions. Such type is usually called "Variant" type.

Resources on Variant Type:

- [https://en.wikipedia.org/wiki/Variant_type](https://en.wikipedia.org/wiki/Variant_type)
- [http://en.cppreference.com/w/cpp/utility/variant](http://en.cppreference.com/w/cpp/utility/variant)
- [https://dlang.org/phobos/std_variant.html](https://dlang.org/phobos/std_variant.html)

Since a Variant type library has to do extra work, mostly around type handling, it might have a negative performance
and memory implications. But even so, having a variable of an unknown type might not always be desirable. Even
PHP community found it to be a bad practice in some cases and for that purpose a type hinting was introduced.

Resources on Type Hinting in PHP:

- [http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration](http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration)

There is an alternative approach which makes it possible to have, to a certain extend, a variable with an unknown type,
but at the same time not to have the downsides of it - that is the Template approach.

Resources on Templates:

- [https://en.wikipedia.org/wiki/Generic_programming](https://en.wikipedia.org/wiki/Generic_programming)
- [https://en.wikipedia.org/wiki/Template_metaprogramming](https://en.wikipedia.org/wiki/Template_metaprogramming)
- [http://en.cppreference.com/w/cpp/language/templates](http://en.cppreference.com/w/cpp/language/templates)
- [http://en.cppreference.com/w/cpp/language/function_template](http://en.cppreference.com/w/cpp/language/function_template)
- [http://en.cppreference.com/w/cpp/language/template_specialization](http://en.cppreference.com/w/cpp/language/template_specialization)
- [https://dlang.org/spec/template.html](https://dlang.org/spec/template.html)

What Phlint does is it uses a template approach when analyzing PHP, doing a fundamentally same process as C compiler
would do. Phlint assumes that all functions that have dynamically typed arguments are templates, and specializes
them per type-set of their invocation.

Template Specialization is one of the [inferences](/code/phlint/inference/) that Phlint applies on the
code prior to applying the [rules](/code/phlint/rule/). As a general rule of thumb inferences should do all
the heavy work of gathering information, and well, inferring, while rules make judgments.

In the expression `$x = sum(5, 6);` Phlint knows that `sum` can be specialized as `sum (int $a, int $b)` and so
it does it in [/code/phlint/inference/TemplateSpecialization.php](/code/phlint/inference/TemplateSpecialization.php).

Specializations are generated by [/code/phlint/inference/TemplateSpecialization.php:67](/code/phlint/inference/TemplateSpecialization.php#TemplateSpecialization.php-67).

Such rewrite could be visualized like, for example:

    <?php

    function sum ($a, $b) {
      return $a + $b;
    }

    // Function `sum (int $a, int $b)` specialized for the expression `sum(5, 6)`.
    function sum__int_int (int $a, int $b) {
      return $a + $b;
    }

    $x = sum__int_int(5, 6);

After the specialization is being generated it is considered to be a new piece of code and all inferences are again
run against it by
[/code/phlint/inference/TemplateSpecialization.php:165](/code/phlint/inference/TemplateSpecialization.php#TemplateSpecialization.php-165).

Since the argument types are now known, they are collected by
[/code/phlint/inference/Concept.php:109](/code/phlint/inference/Concept.php#Concept.php-109)
and propagated to other variables in the function by
[/code/phlint/inference/Concept.php:66](/code/phlint/inference/Concept.php#Concept.php-66).

Finally the
[Require Compatible Concept Rule](/code/phlint/rule/RequireCompatibleConcept.php)
can complain if the variable concepts used in the expression `$a + $b` are
not compatible in such expression in
[/code/phlint/rule/RequireCompatibleConcept.php:256](/code/phlint/rule/RequireCompatibleConcept.php#RequireCompatibleConcept.php-256).
